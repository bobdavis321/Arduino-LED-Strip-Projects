// Version for sending data to 12 Parallel WS2812 strings
// by: BOB Davis  
// Removed Assembler and simplified the code

// PORTD is Digital Pins 0-7 on the Uno change for other boards. 
#define PIXEL_PORT  PORTD  // Port the pixels are connected to
#define PIXEL_DDR   DDRD   // Port the pixels are connected to
// PORT B is D8-D13
#define PIXEL_PORTB  PORTB  // Port the pixels are connected to
#define PIXEL_DDRB   DDRB   // Port the pixels are connected to
int textb=128;  // brightness of text
int maxled=90;
String text1="ARDUINO LED STRIP PROJECTS    ";
// Set default color for letters 
int red=textb; int green=textb; int blue=textb;

// Send the next set of 8 WS2812B encoded bits to the 8 pins.
// The delay timing is for an Arduino UNO.
void sendBitX8( byte bits, byte bith ) {
  PORTD= 0xFF;  // turn on
  PORTB= 0xFF;  // turn on
  PORTD= 0xFF;  // delay
  PORTD= 0xFF;  // delay
  PORTD= 0xFF;  // delay (add more for faster processors)
  PORTD= bits;  // send data
  PORTB= bith;  // send data
  PORTD= bits;  // delay
  PORTD= bits;  // delay
  PORTD= bits;  // delay
  PORTD= 0x00;  // Turn off;
  PORTB= 0x00;  // Turn off;
}

void sendPixelRow( word row ) {
  // separate out upper and lower bytes from word
  byte rowh = row >> 8;
  // Send the bit 8 times down every row, each pixel is 8 bits/color
  int mask = 0x01;  // shifting mask to determine bit status
    for (int bit=8; bit>0; bit--){       
      if (green & (mask<<bit))sendBitX8( row, rowh ); else sendBitX8( 0x0000, 0x0000 ); }
    for (int bit=8; bit>0; bit--){       
      if (red & (mask<<bit))sendBitX8( row, rowh ); else sendBitX8( 0x0000, 0x0000 ); }
    for (int bit=8; bit>0; bit--){       
      if (blue & (mask<<bit))sendBitX8( row, rowh ); else sendBitX8( 0x0000, 0x0000 ); }
 }
    

// Hand typed 8x12 Font rotated to vertical values
// Based on Michael J. Karas of Carousel Design Solutions
word font[][8] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ascii 32 
0x000,0x000,0x780,0xFEC,0xFEC,0x780,0x000,0x000, // !
0x000,0xE00,0xF00,0x000,0x000,0xF00,0xE00,0x000, // "
0x110,0x3FC,0x3FC,0x110,0x3FC,0x3FC,0x110,0x000, // #
0x31C,0x7C6,0x441,0xFFF,0xC43,0x67E,0x33C,0x000, // $
0xE18,0xA30,0xE60,0x0C0,0x19C,0x314,0x61C,0x000, // %
0x678,0xFFC,0x984,0x9C4,0xF78,0x63C,0x068,0x000, // &
0x000,0x000,0x100,0xF00,0xE00,0x000,0x000,0x000, // '
0x000,0x000,0x3F0,0x7F8,0xC0C,0x804,0x000,0x000, // (
0x000,0x000,0x804,0xC0C,0x7F8,0x3F0,0x000,0x000, // )
0x040,0x150,0x1F0,0x0E0,0x1F0,0x150,0x040,0x000, // *
0x0C0,0x0C0,0x0C0,0x3F0,0x3F0,0x0C0,0x0C0,0x0C0, // +
0x000,0x000,0x001,0x00F,0x00E,0x000,0x000,0x000, // ,
0x040,0x040,0x040,0x040,0x040,0x040,0x040,0x000, // -
0x000,0x000,0x00C,0x00C,0x000,0x000,0x000,0x000, // .
0x006,0x00C,0x018,0x030,0x060,0x0C0,0x180,0x300, // /
0x3F0,0x7F8,0xC0C,0x8C4,0xC0C,0x7F8,0x3F0,0x000, // 0
0x000,0x404,0x604,0xFFC,0xFFC,0x004,0x004,0x000, // 1
0x41C,0xC3C,0x864,0x8C4,0x984,0xF0C,0x60C,0x000, // 2
0x408,0xC0C,0x804,0x884,0x884,0xFFC,0x778,0x000, // 3
0x0E0,0x1E0,0x320,0x624,0xFFC,0xFFC,0x024,0x000, // 4
0xF88,0xF8C,0x884,0x884,0x884,0x8FC,0x878,0x000, // 5
0x3F8,0x7FC,0xC84,0x884,0x884,0x8FC,0x078,0x000, // 6
0xC00,0xC00,0x87C,0x8FC,0x980,0xF00,0xE00,0x000, // 7
0x778,0xFFC,0x884,0x884,0x884,0xFFC,0x778,0x000, // 8
0x700,0xF84,0x884,0x884,0x88C,0xFF8,0x7F0,0x000, // 9
0x000,0x000,0x000,0x318,0x318,0x000,0x000,0x000, // :
0x000,0x000,0x002,0x18E,0x18C,0x000,0x000,0x000, // ;
0x000,0x040,0x0E0,0x1B0,0x318,0x60C,0x404,0x000, // <
0x000,0x120,0x120,0x120,0x120,0x120,0x120,0x000, // =
0x000,0x404,0x60C,0x318,0x1B0,0x0E0,0x040,0x000, // >
0x400,0xC00,0x800,0x86C,0x8EC,0xF80,0x700,0x000, // ?
0x7F8,0xFFC,0x804,0x864,0x8E4,0xFE4,0x7C0,0x000, // @
0x1FC,0x3FC,0x640,0xC40,0x640,0x3FC,0x1FC,0x000, // A
0x804,0xFFC,0xFFC,0x884,0x884,0xFFC,0x778,0x000, // B
0x3F0,0x7F8,0xC0C,0x804,0x804,0xC0C,0x618,0x000, // C
0x804,0xFFC,0xFFC,0x804,0xC0C,0x7F8,0x3F0,0x000, // D
0x804,0xFFC,0xFFC,0x884,0x9C4,0xC0C,0xC0C,0x000, // E
0x804,0xFFC,0xFFC,0x884,0x9C0,0xC00,0xC00,0x000, // F
0x3F0,0x7F8,0xC0C,0x804,0x844,0xC78,0x67C,0x000, // G
0xFFC,0xFFC,0x080,0x080,0x080,0xFFC,0xFFC,0x000, // H
0x000,0x804,0x804,0xFFC,0xFFC,0x804,0x804,0x000, // I
0x018,0x01C,0x004,0x804,0xFFC,0xFF8,0x800,0x000, // J
0x804,0xFFC,0xFFC,0x1C0,0x360,0xE3C,0xC1C,0x000, // K
0x804,0xFFC,0xFFC,0x804,0x004,0x00C,0x00C,0x000, // L
0xFFC,0xFFC,0x700,0x380,0x700,0xFFC,0xFFC,0x000, // M
0xFFC,0xFFC,0x300,0x180,0x0C0,0xFFC,0xFFC,0x000, // N
0x7F8,0xFFC,0x804,0x804,0x804,0xFFC,0x7F8,0x000, // O
0x804,0xFFC,0xFFC,0x844,0x840,0xFC0,0x780,0x000, // P
0x7F8,0xFFC,0x808,0x80C,0x806,0xFFF,0x7F9,0x000, // Q
0x804,0xFFC,0xFFC,0x880,0x8C0,0xFFC,0x73C,0x000, // R
0x608,0xF0C,0x984,0x884,0x8C4,0xC7C,0x438,0x000, // S
0xC00,0xC00,0xC04,0xFFC,0xFFC,0xC04,0xC00,0xC00, // T
0xFF8,0xFFC,0x004,0x004,0x004,0xFFC,0xFF8,0x000, // U
0xFE0,0xFF0,0x018,0x00C,0x018,0xFF0,0xFE0,0x000, // V
0xFF0,0xFFC,0x01C,0x070,0x01C,0xFFC,0xFF0,0x000, // W
0xC0C,0xE1C,0x330,0x1E0,0x1E0,0x330,0xE1C,0xC0C, // X
0xE00,0xF00,0x184,0x0FC,0x0FC,0x184,0xF00,0xE00, // Y
0xC1C,0xC3C,0x864,0x8C4,0x984,0xB04,0xE0C,0x000, // Z
};
  

void setup() {
  PIXEL_DDR = 0xFF;    // Set all row pins to output
  PIXEL_DDRB = 0xFF;     // Set pins to output 
}
void loop() {
// 256 SHADE COLOR TEST
  cli();                      // No time for interruptions!
  for (int l=0; l<(maxled/4); l++){ // max number lines to send
    red=l+2; green=0; blue=0;    
    sendPixelRow(0xFFF);       // Light red
  }
  for (int l=0; l<(maxled/4); l++){ // max number lines to send
    red=0; green=l+2; blue=0;    
    sendPixelRow(0xFFF);       // Light green
  }
  for (int l=0; l<(maxled/4); l++){ // max number lines to send
    red=0; green=0; blue=l+2;    
    sendPixelRow(0xFFF);       // Light blue
  }
  for (int l=0; l<(maxled/4); l++){ // max number lines to send
    red=l+2; green=l+2; blue=l+2;    
    sendPixelRow(0xFFF);       // Light white
  }
  sei();
  delay(3000);                  // Wait to display results
  
  red=textb; green=0; blue=0;
  cli();                        // No time for interruptions!
  for (int l=0; l<30; l++){     // 30 is number of characters to send
    switch (l){                 // case is faster than if's
      case 0: red=textb; green=0; blue=0; break; // red
      case 1: red=0; green=textb; blue=0; break;  // green
      case 2: red=0; green=0; blue=textb; break;  // blue
      case 3: red=textb; green=textb; blue=0; break; //yellow
      case 4: red=0; green=textb; blue=textb; break; // cyan
      case 5: red=textb; green=0; blue=textb; break; // purple
      case 6: red=textb; green=0; blue=0; break; // red
      case 7: red=0; green=textb; blue=0; break;  // green
      case 8: red=0; green=0; blue=textb; break;  // blue
      case 9: red=textb; green=textb; blue=0; break; //yellow
      case 10: red=0; green=textb; blue=textb; break; // cyan
      case 11: red=textb; green=0; blue=textb; break; // purple
    }
    // Using a loop is too slow with the character lookups.
    sendPixelRow(font[text1[l]-32][0]); // -32 is to get to correct ascii
    sendPixelRow(font[text1[l]-32][1]); // -32 is to get to correct ascii
    sendPixelRow(font[text1[l]-32][2]); // -32 is to get to correct ascii
    sendPixelRow(font[text1[l]-32][3]); // -32 is to get to correct ascii
    sendPixelRow(font[text1[l]-32][4]); // -32 is to get to correct ascii
    sendPixelRow(font[text1[l]-32][5]); // -32 is to get to correct ascii
    sendPixelRow(font[text1[l]-32][6]); // -32 is to get to correct ascii
    sendPixelRow(font[text1[l]-32][7]); // -32 is to get to correct ascii
  }
  sei();
  delay(8000);                  // Wait to display results
  return;  
}

