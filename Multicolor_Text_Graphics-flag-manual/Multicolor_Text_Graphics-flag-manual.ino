// Version for sending data to 8 Parallel WS2812 strings
// by: BOB Davis  
// Graphics version with Manually entered US Flag

// PORTD is Digital Pins 0-7 on the Uno change for other boards. 
#define PIXEL_PORT  PORTD  // Port the pixels are connected to
#define PIXEL_DDR   DDRD   // Port the pixels are connected to
int textb=128;  // brightness of text
int maxled=180;  // maximum number of LED's insign
//byte sarray[144*3]; // three times max led
int imgwidth=72;  // image number of pixels wide
byte mbyte;
#include <avr/pgmspace.h>

// Set default color for letters 
int red=10; int green=10; int blue=10; 

// Send the next set of 8 WS2812B encoded bits to the 8 pins.
// The delay timing is for an Arduino UNO.
void sendBitX8( byte bits ) {
  PORTD= 0xFF;  // turn on
  PORTD= 0xFF;  // delay
  PORTD= 0xFF;  // delay
  PORTD= 0xFF;  // delay
  PORTD= 0xFF;  // delay (add more for faster processors)
  PORTD= bits;  // send data
  PORTD= bits;  // delay
  PORTD= bits;  // delay
  PORTD= bits;  // delay
  PORTD= bits;  // delay
  PORTD= 0x00;  // Turn off;
}

int mask = 0x01;  // will shift mask to determine bit status
void sendPixelRow( byte mred, byte mgreen, byte mblue ) {
  // Send the bit 8 times down every row, each pixel is 8 bits/color
    for (int mbit=8; mbit>0; mbit--){ 
      if (green & mask<<mbit)sendBitX8( mgreen ); else sendBitX8( 0x00 );} 
    for (int mbit=8; mbit>0; mbit--){       
      if (red & mask<<mbit)sendBitX8( mred ); else sendBitX8( 0x00 ); }
    for (int mbit=8; mbit>0; mbit--){       
      if (blue & mask<<mbit)sendBitX8( mblue ); else sendBitX8( 0x00 ); }
 }
    
static byte sarray[] = {
  // Left corner
  0x00,0x00,0xFF,  0xAA,0xAA,0xFF,  0x00,0x00,0xFF,  0x55,0x55,0xFF,  
  0x00,0x00,0xFF,  0xAA,0xAA,0xFF,  0x00,0x00,0xFF,  0x55,0x55,0xFF,  
  0x00,0x00,0xFF,  0xAA,0xAA,0xFF,  0x00,0x00,0xFF,  0x55,0x55,0xFF,  
  0x00,0x00,0xFF,  0xAA,0xAA,0xFF,  0x00,0x00,0xFF,  0x55,0x55,0xFF,  
  0x00,0x00,0xFF,  0xAA,0xAA,0xFF,  0x00,0x00,0xFF,  0x55,0x55,0xFF,  
  0x00,0x00,0xFF,  0xAA,0xAA,0xFF,  0x00,0x00,0xFF,  0x55,0x55,0xFF,  
  0x00,0x00,0xFF,  0xAA,0xAA,0xFF,  0x00,0x00,0xFF,   
  // Right Side + Bottom
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,  0xFF,0x55,0x55,
  0xFF,0x55,0x55  
};

void setup() {
  PIXEL_DDR = 0xff;    // Set all row pins to output
}

void loop() {
// 256 SHADE COLOR TEST
  int mqtr=maxled/4;  // doing the math several times is too slow
  int mhalf=maxled/2;  // doing the math several times is too slow
  int m3qtr=maxled*.75;  // doing the math several times is too slow
  cli();                      // No time for interruptions!
  for (int l=0; l<(maxled); l++){ // max number lines to send
    red=l; green=0; blue=0;    
    if (l >= mqtr)  { red=0; green=l-mqtr; blue=0;}    
    if (l >= mhalf) { red=0; green=0; blue=l-mhalf;}
    if (l >= m3qtr) { red=l-m3qtr; green=l-m3qtr; blue=l-m3qtr;}
    sendPixelRow( 0xFF, 0xFF, 0xFF );       // Light bits
  }
  sei();
  delay(2000);                  // Wait to display results

  red=textb; green=textb; blue=textb;
  int mmax=maxled*3;
  cli();                        // No time for interruptions!
  for (int l=0; l<mmax; l=l+3){     //  send array
    sendPixelRow(sarray[l], sarray[l+1], sarray[l+2] );  
  }
  sei();
  delay(4000);                  // Wait to display results
  return; 
 
   
}

